{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-07-16T12:48:36.000Z","updated":"2019-07-16T12:48:36.358Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-16T12:48:29.000Z","updated":"2019-07-16T12:48:29.252Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Druid简介","slug":"Druid简介","date":"2019-10-22T03:16:20.000Z","updated":"2019-11-02T03:19:15.765Z","comments":true,"path":"2019/10/22/Druid简介/","link":"","permalink":"http://yoursite.com/2019/10/22/Druid%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Druid简介Apache Druid (incubating) 是一个为对大型数据集进行快速切片和OLAP查询而设计的实时分析数据库。Druid作为数据库主要在以下场景被使用： 实时数据采集 高性能的数据查询 要求服务高可用 因此，Druid经常为BI提供支持，或者作为需要快速聚合的高并发接口的后端。Druid最适合处理面向事件的数据。 Druid常见的应用领域包括： 点击流分析（网络和移动设备） 网络遥测分析（网络性能监测） 服务器指标存储 供应链分析（制造指标） 应用程序性能指标 数字营销/广告分析 商业智能（BI）/ OLAP Druid的核心架构结合了数据仓库、时序数据库和日志检索系统的思想。主要有如下特点： 列式存储 可扩展的分布式系统 大规模的并行处理 实时或批量的数据采集 自愈、负载均衡、易于操作 云原生架构、不会丢失数据的容错架构 用户快速删选数据的索引 基于时间分区 近似算法 在数据采集时自动汇总 Druid选型如果符合以下部分场景，Druid是一个很好的选择： 插入频率高，但是很少更新（时序数据） 大多数的查询都是聚合和报表查询（分组查询） 对查询的延迟有要求（100ms到几分钟） 您的数据有一个时间组件 您可能有多个表，但每个查询只能访问一个大的分布式表。查询可能会遇到多个较小的“查找表” 您有高基数数据列（例如URL、用户ID），需要对它们进行快速计数和排名 您希望从kafka、HDFS、平面文件或类似Amazon S3的对象存储中加载数据 对于以下场景，Druid并不擅长： 您需要根据主键低延迟地更新数据（Druid支持流式插入，但不支持流式更新） 您正在构建一个离线的报表系统，并且对于查询延迟没有要求 您需要支持多表的JOIN操作，并且可以接受这些查询很耗时 Druid架构 Druid服务包含以下节点类型： Coordinator Overload Broker Router Historical MiddleManager 除了上述内部的节点，Druid还有三个外部依赖： Zookeeper Druid利用Zookeeper来实现集群状态的管理，主要实现如下操作： Coordinator节点Leader的选举 从Historical节点发布Segment Coordinator和Historical间Segment的加载/删除 Overload和MiddleManager的任务管理 Metadata Storage 在单节点中，它通常是本地存储的Apache Derby数据库（不适用于生产） 在集群模式中，它通常是MySQL或者PostgreSQL这样的关系型数据库 Deep Storage 支持HDFS、S3、Google Cloud Storage、Microsoft Azure、Apache Cassandra、Rackspace Cloudfiles、Microsoft SQLServer等 Druid的各服务节点可以部署在任务地方，但是为了更方便的部署，官方建议按照如下的服务类型进行部署： Master Servers 运行Coordinator和Overlord节点，管理数据可用性和采集 Query Servers 运行Broker和可选的Router节点，处理来自外部客户端的查询请求 Data Servers 运行Historical和MiddleManager节点，执行数据采集的工作并且存储所有可查询的数据","categories":[],"tags":[{"name":"Druid","slug":"Druid","permalink":"http://yoursite.com/tags/Druid/"}]},{"title":"Java设计模式之单例模式","slug":"Java设计模式之单例模式","date":"2019-07-17T13:41:44.000Z","updated":"2019-07-17T13:41:44.318Z","comments":true,"path":"2019/07/17/Java设计模式之单例模式/","link":"","permalink":"http://yoursite.com/2019/07/17/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java设计模式","slug":"Java设计模式","date":"2013-07-16T12:20:20.000Z","updated":"2019-07-16T12:50:22.894Z","comments":true,"path":"2013/07/16/Java设计模式/","link":"","permalink":"http://yoursite.com/2013/07/16/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"什么是设计模式设计模式是指针对软件开发过程中重复发生的问题的解决方法。说起设计模式，最有名的就是GoF的23种设计模式（本次整理的也均为这23种设计模式）。 设计模式分类GoF将设计模式分为以下三类: 创建型设计模式，共5种 1234567891. 工厂方法模式（Factory Method Pattern）2. 抽象工厂模式（Abstract Factory Pattern）3. 单例模式（Singleton Pattern）4. 建造者模式（Builder Pattern）5. 原型模式（Prototype Pattern） 结构型设计模式，共7种 123456789101112131. 适配器模式（Adapter Pattern）2. 桥接模式（Bridge Pattern）3. 组合模式（Composite Pattern）4. 装饰者模式（Decorator Pattern）5. 外观模式（Facade Pattern）6. 享元模式（Flyweight Pattern）7. 代理模式（Proxy Pattern） 行为型设计模式，共11种 1234567891011121314151617181920211. 责任链模式（Chain of Responsibility Pattern）2. 命令模式（Command Pattern）3. 解释者模式（Interpreter Pattern）4. 迭代模式（Iterator Pattern）5. 中介者模式（Mediator Pattern）6. 备忘录模式（Memento Pattern）7. 观察者模式（Observer Pattern） 8. 状态模式（State Pattern） 9. 策略模式（Strategy Pattern） 10.模板方法模式（Template Method Pattern） 11.访问者模式（Visitor Pattern） 设计模式6大原则 开闭原则 （Open Close Principle） 12对扩展开放，对修改关闭。实现开闭原则的关键就在于“抽象”，用抽象去构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。 里氏替换原则（Liskov Substitution Principle） “Inheritance should ensure that any property proved about supertype objects also holds for subtype objects.”——“继承必须确保超类所拥有的性质在子类中仍然成立。” 1子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 依赖倒置原则（Dependence Inversion Principle） 1针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 1234567接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 迪米特法则（Demeter Principle） 123Talk only to your immediate friends。 外观模式（Facade）和中介者模式（Mediator），都是迪米特法则应用的例子。 合成复用原则（Composite Reuse Principle） 1尽量使用对象组合，而不是继承来达到复用的目的。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}]}